---
layout: none
---

<head>
    <title>Blobs</title>
    {% include favicon.html %}
</head>

<style>
    canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
    }
</style>
<canvas id="canv"></canvas>

<script>
    // Single variable to control metaball size - lower = bigger blobs
    const threshold = 5.0;
    
    // Field strength multiplier - higher = stronger field influence
    const fieldStrength = 5.0;

    let blobs = [];
    
    // Vertex Shader
    const vertexSource = `
    attribute vec2 a_position;
    void main() {
        gl_Position = vec4(a_position, 0.0, 1.0);
    }
    `;

    // Fragment Shader
    const fragmentSource = `
    precision mediump float;

    uniform vec2 u_resolution;
    uniform vec3 u_blobs[5]; // 5 blobs: x, y, radius
    uniform float u_threshold; // Single threshold control
    uniform float u_fieldStrength; // Field strength multiplier

    float field(vec2 p) {
        float sum = 0.0;
        for (int i = 0; i < 5; i++) {
            vec2 d = p - u_blobs[i].xy;
            float r = u_blobs[i].z;
            sum += (r * r * u_fieldStrength) / (dot(d, d) + 0.01);
        }
        return sum;
    }

    void main() {
        vec2 p = gl_FragCoord.xy; 
        float f = field(p);
        
        // Create smooth metaball effect using threshold
        float color = smoothstep(u_threshold, u_threshold * 1.6, f);
        
        // Add some color variety based on field strength
        vec3 col = vec3(color);
        if (f > u_threshold * 1.2) {
            col = mix(vec3(0.2, 0.5, 1.0), vec3(1.0, 0.3, 0.5), smoothstep(u_threshold * 1.2, u_threshold * 3.0, f));
        }
        
        gl_FragColor = vec4(col, 1.0); 
    }
    `;

    const canvas = document.getElementById("canv");
    const gl = canvas.getContext("webgl");
    
    if (!gl) {
        alert("WebGL not supported");
        // TODO: Fallback to 2D canvas rendering if WebGL is not available.
    }

    let resolutionLoc, blobsLoc, thresholdLoc, fieldStrengthLoc;

    class Blob {
        constructor(x, y, r, dx, dy) {
            this.x = x;
            this.y = y;
            this.r = r;
            this.dx = dx;
            this.dy = dy;
        }
    }

    function createRandomBlobs(numBlobs) {
        const blobs = [];
        for (let i = 0; i < numBlobs; i++) {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            const r = 50 + Math.random() * 100;
            const dx = (Math.random() - 0.5) * 8;
            const dy = (Math.random() - 0.5) * 8;
            blobs.push(new Blob(x, y, r, dx, dy));
        }
        return blobs;
    }

    

    function compileShader(type, src) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, src);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }

    function createProgram(vertexShader, fragmentShader) {
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program linking error:', gl.getProgramInfoLog(program));
            gl.deleteProgram(program);
            return null;
        }
        return program;
    }

    function setupGL() {
        // Set canvas size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const vertexShader = compileShader(gl.VERTEX_SHADER, vertexSource);
        const fragmentShader = compileShader(gl.FRAGMENT_SHADER, fragmentSource);

        if (!vertexShader || !fragmentShader) {
            return false;
        }

        const program = createProgram(vertexShader, fragmentShader);
        if (!program) {
            return false;
        }

        gl.useProgram(program);

        // Create full screen quad
        const posBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1, -1,  1, -1, -1,  1,
            -1,  1,  1, -1,  1,  1
        ]), gl.STATIC_DRAW);

        const posLoc = gl.getAttribLocation(program, "a_position");
        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

        // Get uniform locations
        resolutionLoc = gl.getUniformLocation(program, "u_resolution");
        blobsLoc = gl.getUniformLocation(program, "u_blobs");
        thresholdLoc = gl.getUniformLocation(program, "u_threshold");
        fieldStrengthLoc = gl.getUniformLocation(program, "u_fieldStrength");

        return true;
    }

    function update() {
        for (const blob of blobs) {
            blob.x += blob.dx / 10;
            blob.y += blob.dy / 10;
            
            // Bounce off walls (centers only)
            if (blob.x <= 0 || blob.x >= canvas.width) {
                blob.dx *= -1;
            }
            if (blob.y <= 0 || blob.y >= canvas.height) {
                blob.dy *= -1;
            }
        }
    }

    function render() {
        if (blobs.length === 0) {
            blobs = createRandomBlobs(5);
        }
        update();

        // Set viewport
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.uniform2f(resolutionLoc, canvas.width, canvas.height);
        gl.uniform1f(thresholdLoc, threshold);
        gl.uniform1f(fieldStrengthLoc, fieldStrength);

        // Update blob uniforms
        const blobData = [];
        for (const blob of blobs) {
            blobData.push(blob.x, blob.y, blob.r);
        }
        gl.uniform3fv(blobsLoc, new Float32Array(blobData));

        // Clear and draw
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.drawArrays(gl.TRIANGLES, 0, 6);

        requestAnimationFrame(render);
    }

    // Handle window resize
    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        setupGL();
    });

    // Initialize and start
    if (setupGL()) {
        render();
    } else {
        console.error('Failed to initialize WebGL');
    }
</script>

<!-- 
<script>
    const canvas = document.getElementById("canv");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const blobs = [
        { x: 200, y: 200, r: 100, dx: 1, dy: 0.7 },
        { x: 400, y: 300, r: 200, dx: -2, dy: -0.5 },
        { x: 100, y: 320, r: 250, dx: -2, dy: -0.5 },
        { x: 300, y: 480, r: 50, dx: -2, dy: -0.5 },
        { x: 400, y: 100, r: 75, dx: -2, dy: -0.5 },
    ];

    const threshold = 1.0;

    function field(x, y) {
        let sum = 0;
        for (const b of blobs) {
            let dx = x - b.x;
            let dy = y - b.y;
            sum += (b.r * b.r) / (dx * dx + dy * dy + 1); // +1 to avoid div by 0
        }
        return sum;
    }

    function drawMetaballs() {
        const img = ctx.createImageData(canvas.width, canvas.height);
        const data = img.data;
        
        for (let y = 0; y < canvas.height; y += 1) {
            for (let x = 0; x < canvas.width; x += 1) {
                const v = field(x, y);
                const idx = (y * canvas.width + x) * 4;
                if (v > threshold) {
                    data[idx] = 100;   // R
                    data[idx + 1] = 180; // G
                    data[idx + 2] = 255; // B
                }

                data[idx + 3] = 255; // A
            }
        }
        
        ctx.putImageData(img, 0, 0);
    }

    function update() {
        for (const b of blobs) {
            b.x += b.dx;
            b.y += b.dy;
            if (b.x - b.r < 0 || b.x + b.r > canvas.width) b.dx *= -1;
            if (b.y - b.r < 0 || b.y + b.r > canvas.height) b.dy *= -1;
        }
    }

    function animate() {
        update();
        drawMetaballs();
        requestAnimationFrame(animate);
    }

    animate();
</script> -->

<!-- <script>
    // Marching squares implementation
    const canvas = document.getElementById("canv");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const blobs = [
        { x: 200, y: 200, r: 100, dx: 1, dy: 0.07 },
        { x: 400, y: 300, r: 200, dx: -2, dy: -0.05 },
        { x: 100, y: 320, r: 250, dx: -2, dy: -0.05 },
        { x: 300, y: 480, r: 50, dx: -2, dy: -0.05 },
        { x: 400, y: 100, r: 75, dx: -2, dy: -0.05 },
    ];

    const threshold = 1.0;
    // Size of each cell in px (smaller = smoother, slower)
    const gridSize = 8;

    function field(x, y) {
        let sum = 0;
        for (const b of blobs) {
            let dx = x - b.x;
            let dy = y - b.y;
            sum += (b.r * b.r) / (dx * dx + dy * dy + 1);
        }
        return sum;
    }

    // Interpolates the crossing between two grid points
    function lerp(a, b, va, vb) {
        return a + (threshold - va) * (b - a) / (vb - va);
    }

    // Draw metaballs with marching squares
    function drawMetaballs() {
        ctx.fillStyle = "#000000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.beginPath();

        for (let y = 0; y < canvas.height; y += gridSize) {
            for (let x = 0; x < canvas.width; x += gridSize) {
                // Values at corners
                const v0 = field(x, y);
                const v1 = field(x + gridSize, y);
                const v2 = field(x + gridSize, y + gridSize);
                const v3 = field(x, y + gridSize);

                // Binary index for case lookup
                let idx = 0;
                if (v0 > threshold) idx |= 1;
                if (v1 > threshold) idx |= 2;
                if (v2 > threshold) idx |= 4;
                if (v3 > threshold) idx |= 8;

                if (idx === 0 || idx === 15) continue; // empty or full

                // Edge intersections
                let edges = [];
                if ((idx & 1) !== (idx & 2)) { // between v0-v1
                    let px = lerp(x, x + gridSize, v0, v1);
                    edges.push([px, y]);
                }
                if ((idx & 2) !== (idx & 4)) { // between v1-v2
                    let py = lerp(y, y + gridSize, v1, v2);
                    edges.push([x + gridSize, py]);
                }
                if ((idx & 4) !== (idx & 8)) { // between v2-v3
                    let px = lerp(x + gridSize, x, v2, v3);
                    edges.push([px, y + gridSize]);
                }
                if ((idx & 8) !== (idx & 1)) { // between v3-v0
                    let py = lerp(y + gridSize, y, v3, v0);
                    edges.push([x, py]);
                }

                // Draw segment(s)
                if (edges.length === 2) {
                    ctx.moveTo(edges[0][0], edges[0][1]);
                    ctx.lineTo(edges[1][0], edges[1][1]);
                }
            }
        }

        ctx.strokeStyle = "rgb(100,180,255)";
        ctx.lineWidth = 2;
        ctx.stroke();
    }

    function update() {
        for (const b of blobs) {
            b.x += b.dx;
            b.y += b.dy;
            if (b.x - b.r < 0 || b.x + b.r > canvas.width) b.dx *= -1;
            if (b.y - b.r < 0 || b.y + b.r > canvas.height) b.dy *= -1;
        }
    }

    function animate() {
        update();
        drawMetaballs();
        requestAnimationFrame(animate);
    }

    animate();
</script> -->