---
layout: none
---

<head>
    <title>Blobs</title>
    {% include favicon.html %}
</head>

<style>
    canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
    }
</style>
<canvas id="canv"></canvas>

<script>
    // Single variable to control metaball size - lower = bigger blobs
    const threshold = 5.0;

    // Field strength multiplier - higher = stronger field influence - more gloop and bigger blob
    const fieldStrength = 5.0;

    let blobCount = 8;
    let cpuRes = 8;

    const url = new URL(window.location.href); // current page URL
    const params = new URLSearchParams(url.search);

    let gpu = params.get("gpu") === "1";

    let blobs = [];

    // Vertex Shader
    const vertexSource = `
            attribute vec2 a_position;
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
            `;

    // Fragment Shader
    const fragmentSource = `
            precision mediump float;

            uniform vec2 u_resolution;
            uniform vec3 u_blobs[${blobCount}]; // 5 blobs: x, y, radius
            uniform float u_threshold; // Single threshold control
            uniform float u_fieldStrength; // Field strength multiplier

            float field(vec2 p) {
                float sum = 0.0;
                for (int i = 0; i < ${blobCount}; i++) {
                    vec2 d = p - u_blobs[i].xy;
                    float r = u_blobs[i].z;
                    sum += (r * r * u_fieldStrength) / (dot(d, d) + 0.01);
                }
                return sum;
            }

            void main() {
                vec2 p = gl_FragCoord.xy;
                float f = field(p);

                // Create smooth metaball effect using threshold
                float color = smoothstep(u_threshold, u_threshold * 1.6, f);

                // Add some color variety based on field strength
                vec3 col = vec3(color);
                if (f > u_threshold * 1.2) {
                    col = mix(vec3(0.2, 0.5, 1.0), vec3(1.0, 0.3, 0.5), smoothstep(u_threshold * 1.2, u_threshold * 3.0, f));
                }

                gl_FragColor = vec4(col, 1.0);
            }
            `;

    const canvas = document.getElementById("canv");
    let gl;
    let ctx;

    if (gpu) {
        gl = canvas.getContext("webgl2");

        if (!gl) {
            gl = canvas.getContext("webgl");
        }
        if (!gl) {
            ctx = canvas.getContext("2d");
            gpu = false;
        }
    } else {
        ctx = canvas.getContext("2d");
        gpu = false;
    }

    let resolutionLoc, blobsLoc, thresholdLoc, fieldStrengthLoc;

    class Blob {
        constructor(x, y, r, dx, dy) {
            this.x = x;
            this.y = y;
            this.r = r;
            this.dx = dx;
            this.dy = dy;
        }
    }

    function createRandomBlobs(numBlobs) {
        const blobs = [];
        for (let i = 0; i < numBlobs; i++) {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            const r = 50 + Math.random() * 100;
            let dx = (Math.random() - 0.5) * 8;
            let dy = (Math.random() - 0.5) * 8;

            if (!gpu) {
                dx *= 10;
                dy *= 10;
            }

            blobs.push(new Blob(x, y, r, dx, dy));
        }
        return blobs;
    }

    function compileShader(type, src) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, src);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error("Shader compilation error:", gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }

    function createProgram(vertexShader, fragmentShader) {
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error("Program linking error:", gl.getProgramInfoLog(program));
            gl.deleteProgram(program);
            return null;
        }
        return program;
    }

    function setupGL() {
        // Set canvas size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const vertexShader = compileShader(gl.VERTEX_SHADER, vertexSource);
        const fragmentShader = compileShader(gl.FRAGMENT_SHADER, fragmentSource);

        if (!vertexShader || !fragmentShader) {
            return false;
        }

        const program = createProgram(vertexShader, fragmentShader);
        if (!program) {
            return false;
        }

        gl.useProgram(program);

        // Create full screen quad
        const posBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);

        const posLoc = gl.getAttribLocation(program, "a_position");
        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

        // Get uniform locations
        resolutionLoc = gl.getUniformLocation(program, "u_resolution");
        blobsLoc = gl.getUniformLocation(program, "u_blobs");
        thresholdLoc = gl.getUniformLocation(program, "u_threshold");
        fieldStrengthLoc = gl.getUniformLocation(program, "u_fieldStrength");

        return true;
    }

    function update() {
        if (blobs.length === 0) {
            blobs = createRandomBlobs(blobCount);
        }

        for (const blob of blobs) {
            blob.x += blob.dx / 10;
            blob.y += blob.dy / 10;

            // Bounce off walls (centers only)
            if (blob.x <= 0 ) {
                blob.dx *= -1;
                blob.x = 0;
            } else if (blob.x >= canvas.width) {
                blob.dx *= -1;
                blob.x = canvas.width;
            }
            if (blob.y <= 0 || blob.y >= canvas.height) {
                blob.dy *= -1;
            }
        }
    }

    function render() {
        update();

        // Set viewport
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.uniform2f(resolutionLoc, canvas.width, canvas.height);
        gl.uniform1f(thresholdLoc, threshold);
        gl.uniform1f(fieldStrengthLoc, fieldStrength);

        // Update blob uniforms
        const blobData = [];
        for (const blob of blobs) {
            blobData.push(blob.x, blob.y, blob.r);
        }
        gl.uniform3fv(blobsLoc, new Float32Array(blobData));

        // Clear and draw
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.drawArrays(gl.TRIANGLES, 0, 6);

        requestAnimationFrame(render);
    }

    function field(x, y) {
        let sum = 0;
        for (const b of blobs) {
            let dx = x - b.x;
            let dy = y - b.y;
            sum += (b.r * b.r) / (dx * dx + dy * dy + 1); // +1 to avoid div by 0
        }
        return sum;
    }

    function drawMetaballs() {
        let minX = canvas.width;
        let minY = canvas.height;
        let maxX = 0;
        let maxY = 0;

        for (const b of blobs) {
            minX = Math.min(minX, b.x - b.r * 2);
            minY = Math.min(minY, b.y - b.r * 2);
            maxX = Math.max(maxX, b.x + b.r * 2);
            maxY = Math.max(maxY, b.y + b.r * 2);
        }

        // console.log(`${minX}, ${minY}, ${maxX}, ${maxY}`);
        // x > minX && y > minY && x < maxX && y < maxY

        const img = ctx.createImageData(canvas.width, canvas.height);
        const data = img.data;

        for (let y = 0; y < canvas.height; y += cpuRes) {
            for (let x = 0; x < canvas.width; x += cpuRes) {
                const v = field(x, y);

                let r,
                    g,
                    b,
                    a = 255;
                if (v > threshold / 3) {
                    r = 252;
                    g = 3;
                    b = 161;
                } else if (v > threshold / 6) {
                    r = 100;
                    g = 180;
                    b = 255;
                } else {
                    r = g = b = 0;
                }

                // Make sure we dont spill over the edge
                const blockWidth = Math.min(cpuRes, canvas.width - x);
                const blockHeight = Math.min(cpuRes, canvas.height - y);

                // Fill a 2Ã—2 block
                for (let dy = 0; dy < blockHeight; dy++) {
                    for (let dx = 0; dx < blockWidth; dx++) {
                        const px = ((y + dy) * canvas.width + (x + dx)) * 4;
                        data[px] = r;
                        data[px + 1] = g;
                        data[px + 2] = b;
                        data[px + 3] = a;
                    }
                }
            }
        }
        ctx.putImageData(img, 0, 0);
    }

    function animate() {
        update();
        drawMetaballs();

        // Draw radii
        // for (const b of blobs) {
        //     ctx.beginPath();
        //     ctx.arc(b.x, b.y, b.r * 0.75, 0, Math.PI * 2); // full circle
        //     ctx.strokeStyle = "black"; // circle outline
        //     ctx.lineWidth = 2;
        //     ctx.stroke();
        // }

        requestAnimationFrame(animate);
    }

    function setupAnim() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }

    // Handle window resize
    window.addEventListener("resize", () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        if (gpu) {
            if (setupGL()) {
                render();
            }
        } else {
            console.log("Using cpu-based instead");
            setupAnim();
        }
    });

    function swapMethod() {
        const url = new URL(window.location.href);

        if (gpu) {
            url.searchParams.set("gpu", "0");
        } else {
            url.searchParams.set("gpu", "1");
        }

        window.location.href = url.toString();
    }

    window.addEventListener("keydown", (event) => {
        if (event.code === "KeyG") {
            swapMethod();
        }
    });

    // Initialize and start
    if (gpu) {
        if (setupGL()) {
            render();
        }
    } else {
        console.log("Using cpu-based instead");
        setupAnim();
        animate();
    }
</script>

<!-- 
<script>
    const canvas = document.getElementById("canv");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const blobs = [
        { x: 200, y: 200, r: 100, dx: 1, dy: 0.7 },
        { x: 400, y: 300, r: 200, dx: -2, dy: -0.5 },
        { x: 100, y: 320, r: 250, dx: -2, dy: -0.5 },
        { x: 300, y: 480, r: 50, dx: -2, dy: -0.5 },
        { x: 400, y: 100, r: 75, dx: -2, dy: -0.5 },
    ];

    const threshold = 1.0;

    function field(x, y) {
        let sum = 0;
        for (const b of blobs) {
            let dx = x - b.x;
            let dy = y - b.y;
            sum += (b.r * b.r) / (dx * dx + dy * dy + 1); // +1 to avoid div by 0
        }
        return sum;
    }

    function drawMetaballs() {
        const img = ctx.createImageData(canvas.width, canvas.height);
        const data = img.data;
        
        for (let y = 0; y < canvas.height; y += 1) {
            for (let x = 0; x < canvas.width; x += 1) {
                const v = field(x, y);
                const idx = (y * canvas.width + x) * 4;
                if (v > threshold) {
                    data[idx] = 100;   // R
                    data[idx + 1] = 180; // G
                    data[idx + 2] = 255; // B
                }

                data[idx + 3] = 255; // A
            }
        }
        
        ctx.putImageData(img, 0, 0);
    }

    function update() {
        for (const b of blobs) {
            b.x += b.dx;
            b.y += b.dy;
            if (b.x - b.r < 0 || b.x + b.r > canvas.width) b.dx *= -1;
            if (b.y - b.r < 0 || b.y + b.r > canvas.height) b.dy *= -1;
        }
    }

    function animate() {
        update();
        drawMetaballs();
        requestAnimationFrame(animate);
    }

    animate();
</script> -->

<!-- <script>
    // Marching squares implementation
    const canvas = document.getElementById("canv");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const blobs = [
        { x: 200, y: 200, r: 100, dx: 1, dy: 0.07 },
        { x: 400, y: 300, r: 200, dx: -2, dy: -0.05 },
        { x: 100, y: 320, r: 250, dx: -2, dy: -0.05 },
        { x: 300, y: 480, r: 50, dx: -2, dy: -0.05 },
        { x: 400, y: 100, r: 75, dx: -2, dy: -0.05 },
    ];

    const threshold = 1.0;
    // Size of each cell in px (smaller = smoother, slower)
    const gridSize = 8;

    function field(x, y) {
        let sum = 0;
        for (const b of blobs) {
            let dx = x - b.x;
            let dy = y - b.y;
            sum += (b.r * b.r) / (dx * dx + dy * dy + 1);
        }
        return sum;
    }

    // Interpolates the crossing between two grid points
    function lerp(a, b, va, vb) {
        return a + (threshold - va) * (b - a) / (vb - va);
    }

    // Draw metaballs with marching squares
    function drawMetaballs() {
        ctx.fillStyle = "#000000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.beginPath();

        for (let y = 0; y < canvas.height; y += gridSize) {
            for (let x = 0; x < canvas.width; x += gridSize) {
                // Values at corners
                const v0 = field(x, y);
                const v1 = field(x + gridSize, y);
                const v2 = field(x + gridSize, y + gridSize);
                const v3 = field(x, y + gridSize);

                // Binary index for case lookup
                let idx = 0;
                if (v0 > threshold) idx |= 1;
                if (v1 > threshold) idx |= 2;
                if (v2 > threshold) idx |= 4;
                if (v3 > threshold) idx |= 8;

                if (idx === 0 || idx === 15) continue; // empty or full

                // Edge intersections
                let edges = [];
                if ((idx & 1) !== (idx & 2)) { // between v0-v1
                    let px = lerp(x, x + gridSize, v0, v1);
                    edges.push([px, y]);
                }
                if ((idx & 2) !== (idx & 4)) { // between v1-v2
                    let py = lerp(y, y + gridSize, v1, v2);
                    edges.push([x + gridSize, py]);
                }
                if ((idx & 4) !== (idx & 8)) { // between v2-v3
                    let px = lerp(x + gridSize, x, v2, v3);
                    edges.push([px, y + gridSize]);
                }
                if ((idx & 8) !== (idx & 1)) { // between v3-v0
                    let py = lerp(y + gridSize, y, v3, v0);
                    edges.push([x, py]);
                }

                // Draw segment(s)
                if (edges.length === 2) {
                    ctx.moveTo(edges[0][0], edges[0][1]);
                    ctx.lineTo(edges[1][0], edges[1][1]);
                }
            }
        }

        ctx.strokeStyle = "rgb(100,180,255)";
        ctx.lineWidth = 2;
        ctx.stroke();
    }

    function update() {
        for (const b of blobs) {
            b.x += b.dx;
            b.y += b.dy;
            if (b.x - b.r < 0 || b.x + b.r > canvas.width) b.dx *= -1;
            if (b.y - b.r < 0 || b.y + b.r > canvas.height) b.dy *= -1;
        }
    }

    function animate() {
        update();
        drawMetaballs();
        requestAnimationFrame(animate);
    }

    animate();
</script> -->
